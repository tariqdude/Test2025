---
/**
 * RevealOnScroll - Modern scroll-based reveal animations
 *
 * Features:
 * - Intersection Observer for performance
 * - Multiple animation types
 * - Stagger support for child elements
 * - Configurable thresholds and delays
 */

export interface Props {
  animation?:
    | 'fade'
    | 'slide-up'
    | 'slide-down'
    | 'slide-left'
    | 'slide-right'
    | 'scale'
    | 'flip';
  duration?: number; // in milliseconds
  delay?: number; // in milliseconds
  threshold?: number; // 0 to 1, how much of element should be visible
  once?: boolean; // animate only once
  stagger?: number; // delay between child elements in ms
  className?: string;
  children?: boolean; // animate children individually
}

const {
  animation = 'fade',
  duration = 600,
  delay = 0,
  threshold = 0.1,
  once = true,
  stagger = 0,
  className = '',
  children = false,
} = Astro.props;

const animations = {
  fade: {
    initial: 'opacity: 0;',
    animate: 'opacity: 1;',
  },
  'slide-up': {
    initial: 'opacity: 0; transform: translateY(30px);',
    animate: 'opacity: 1; transform: translateY(0);',
  },
  'slide-down': {
    initial: 'opacity: 0; transform: translateY(-30px);',
    animate: 'opacity: 1; transform: translateY(0);',
  },
  'slide-left': {
    initial: 'opacity: 0; transform: translateX(30px);',
    animate: 'opacity: 1; transform: translateX(0);',
  },
  'slide-right': {
    initial: 'opacity: 0; transform: translateX(-30px);',
    animate: 'opacity: 1; transform: translateX(0);',
  },
  scale: {
    initial: 'opacity: 0; transform: scale(0.9);',
    animate: 'opacity: 1; transform: scale(1);',
  },
  flip: {
    initial: 'opacity: 0; transform: perspective(400px) rotateY(20deg);',
    animate: 'opacity: 1; transform: perspective(400px) rotateY(0);',
  },
};

const animConfig = animations[animation];
const uniqueId = `reveal-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`reveal-element ${className}`}
  data-reveal-id={uniqueId}
  data-reveal-animation={animation}
  data-reveal-duration={duration}
  data-reveal-delay={delay}
  data-reveal-threshold={threshold}
  data-reveal-once={once}
  data-reveal-stagger={stagger}
  data-reveal-children={children}
  style={animConfig.initial}
>
  <slot />
</div>

<script>
  class RevealOnScroll {
    observer;
    animated;

    constructor() {
      this.animated = new Set();
      this.observer = new IntersectionObserver(
        entries => this.handleIntersection(entries),
        {
          threshold: 0.1, // Default, will be overridden per element
          rootMargin: '0px',
        }
      );

      this.init();
    }

    init() {
      // Find all reveal elements
      const elements = document.querySelectorAll('[data-reveal-id]');
      elements.forEach(el => {
        if (el instanceof HTMLElement) {
          const threshold = parseFloat(el.dataset.revealThreshold || '0.1');

          // Create a new observer with custom threshold for this element
          const customObserver = new IntersectionObserver(
            entries => this.handleIntersection(entries),
            {
              threshold,
              rootMargin: '0px',
            }
          );

          customObserver.observe(el);
        }
      });
    }

    handleIntersection(entries: IntersectionObserverEntry[]) {
      entries.forEach(entry => {
        const el = entry.target as HTMLElement;
        const id = el.dataset.revealId;
        const once = el.dataset.revealOnce === 'true';

        if (!id) return;

        if (entry.isIntersecting) {
          // Element is visible
          if (!this.animated.has(id)) {
            this.animateElement(el);
            if (once) {
              this.animated.add(id);
            }
          }
        } else if (!once && this.animated.has(id)) {
          // Element is not visible and once is false, reset
          this.resetElement(el);
          this.animated.delete(id);
        }
      });
    }

    animateElement(el: HTMLElement) {
      const animation = el.dataset.revealAnimation || 'fade';
      const duration = parseInt(el.dataset.revealDuration || '600');
      const delay = parseInt(el.dataset.revealDelay || '0');
      const stagger = parseInt(el.dataset.revealStagger || '0');
      const animateChildren = el.dataset.revealChildren === 'true';

      // Set transition
      el.style.transition = `all ${duration}ms cubic-bezier(0.4, 0, 0.2, 1) ${delay}ms`;

      // Apply animation
      setTimeout(() => {
        const animations: Record<string, string> = {
          fade: 'opacity: 1;',
          'slide-up': 'opacity: 1; transform: translateY(0);',
          'slide-down': 'opacity: 1; transform: translateY(0);',
          'slide-left': 'opacity: 1; transform: translateX(0);',
          'slide-right': 'opacity: 1; transform: translateX(0);',
          scale: 'opacity: 1; transform: scale(1);',
          flip: 'opacity: 1; transform: perspective(400px) rotateY(0);',
        };

        el.style.cssText += animations[animation] || animations.fade;

        // Animate children if enabled
        if (animateChildren && stagger > 0) {
          const children = Array.from(el.children) as HTMLElement[];
          children.forEach((child, index) => {
            child.style.transition = `all ${duration}ms cubic-bezier(0.4, 0, 0.2, 1) ${delay + index * stagger}ms`;
            setTimeout(() => {
              child.style.cssText += animations[animation] || animations.fade;
            }, 10);
          });
        }
      }, 10);
    }

    resetElement(el: HTMLElement) {
      const animation = el.dataset.revealAnimation || 'fade';
      const animations: Record<string, string> = {
        fade: 'opacity: 0;',
        'slide-up': 'opacity: 0; transform: translateY(30px);',
        'slide-down': 'opacity: 0; transform: translateY(-30px);',
        'slide-left': 'opacity: 0; transform: translateX(30px);',
        'slide-right': 'opacity: 0; transform: translateX(-30px);',
        scale: 'opacity: 0; transform: scale(0.9);',
        flip: 'opacity: 0; transform: perspective(400px) rotateY(20deg);',
      };

      el.style.cssText = animations[animation];
    }
  }

  // Initialize on page load
  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        new RevealOnScroll();
      });
    } else {
      new RevealOnScroll();
    }
  }
</script>

<style>
  .reveal-element {
    will-change: transform, opacity;
  }
</style>
